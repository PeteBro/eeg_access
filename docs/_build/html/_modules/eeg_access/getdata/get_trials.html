

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>eeg_access.getdata.get_trials &mdash; eeg_access  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            eeg_access
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">eeg_access</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">eeg_access.getdata.get_trials</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for eeg_access.getdata.get_trials</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Trial metadata lookup and data loader.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_metadata</span>


<div class="viewcode-block" id="TrialHandler">
<a class="viewcode-back" href="../../../api.html#eeg_access.TrialHandler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TrialHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load and filter EEG trial data from a versioned zarr-backed dataset.</span>

<span class="sd">    Point this class at your dataset root folder and tell it which data version</span>
<span class="sd">    you want to work with.  It will find the matching metadata table</span>
<span class="sd">    automatically, giving you a simple interface to select and load trials.</span>

<span class="sd">    The dataset is expected to follow this layout::</span>

<span class="sd">        dataset_root/</span>
<span class="sd">        └── .../ (any depth)</span>
<span class="sd">            └── &lt;version&gt;/</span>
<span class="sd">                ├── *metadata.tsv</span>
<span class="sd">                └── sub-XX/</span>
<span class="sd">                    └── chunk-XX/   ← zarr stores</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset_root : str</span>
<span class="sd">        Top-level folder of your dataset (e.g. ``&#39;/data/eeg_study&#39;``).</span>
<span class="sd">    version : str</span>
<span class="sd">        Name of the data version directory to load (e.g. ``&#39;v2&#39;`` or</span>
<span class="sd">        ``&#39;preprocessed_v3&#39;``).  The directory can sit anywhere under</span>
<span class="sd">        *dataset_root* — it will be located automatically.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; loader = TrialHandler(&#39;/data/eeg_study&#39;, version=&#39;v2&#39;)</span>

<span class="sd">    &gt;&gt;&gt; # Load a specific subset by filtering inline</span>
<span class="sd">    &gt;&gt;&gt; result = loader.get_data(subject=&#39;sub-01&#39;, shared=True)</span>

<span class="sd">    &gt;&gt;&gt; # Or look up a trial table first, then load</span>
<span class="sd">    &gt;&gt;&gt; trials = loader.lookup_trials(subject=&#39;sub-01&#39;, shared=True)</span>
<span class="sd">    &gt;&gt;&gt; result = loader.get_data(trials)</span>
<span class="sd">    &gt;&gt;&gt; result[&#39;data&#39;].shape   # (n_trials, n_channels, n_samples)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_root</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locate the metadata table for *version* and load it.&quot;&quot;&quot;</span>
<span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">lookup_path</span> <span class="o">=</span> <span class="n">find_metadata</span><span class="p">(</span><span class="n">dataset_root</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">lookup_path</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#</span>
<div class="viewcode-block" id="TrialHandler.lookup_trials">
<a class="viewcode-back" href="../../../api.html#eeg_access.TrialHandler.lookup_trials">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_trials</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset of the metadata table matching the given criteria.</span>

<span class="sd">        Pass any metadata column as a keyword argument to filter trials.</span>
<span class="sd">        Multiple filters are combined with ``cond=&#39;and&#39;`` (all criteria must</span>
<span class="sd">        match) or ``cond=&#39;or&#39;`` (any criterion is enough).  The returned</span>
<span class="sd">        DataFrame can be passed directly to :meth:`get_data` or</span>
<span class="sd">        :meth:`iter_data`, or inspected before loading.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cond : {&#39;and&#39;, &#39;or&#39;}, optional</span>
<span class="sd">            How to combine multiple filters.  ``&#39;and&#39;`` (default) keeps only</span>
<span class="sd">            trials that satisfy **all** filters; ``&#39;or&#39;`` keeps trials that</span>
<span class="sd">            satisfy **at least one**.</span>
<span class="sd">        **filters</span>
<span class="sd">            Column name / value pairs.  The value can be a single item or a</span>
<span class="sd">            list.  For example ``nsd_id=[1, 2, 3]`` keeps only trials whose</span>
<span class="sd">            ``nsd_id`` column is 1, 2, or 3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            Filtered metadata table, sorted by the filter columns and with a</span>
<span class="sd">            fresh integer index.  Pass this directly to :meth:`get_data`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # All shared trials for subject 01</span>
<span class="sd">        &gt;&gt;&gt; trials = loader.lookup_trials(subject=&#39;sub-01&#39;, shared=True)</span>

<span class="sd">        &gt;&gt;&gt; # Trials from subject 01 OR subject 02</span>
<span class="sd">        &gt;&gt;&gt; trials = loader.lookup_trials(cond=&#39;or&#39;, subject=[&#39;sub-01&#39;, &#39;sub-02&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">]</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cond</span> <span class="o">==</span> <span class="s1">&#39;and&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond</span> <span class="o">==</span> <span class="s1">&#39;or&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">filters</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<span class="c1">#</span>
<div class="viewcode-block" id="TrialHandler.get_data">
<a class="viewcode-back" href="../../../api.html#eeg_access.TrialHandler.get_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trials</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tmax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">average_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cond</span><span class="o">=</span><span class="s1">&#39;and&#39;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">filters</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load EEG data into memory, with optional inline trial filtering.</span>

<span class="sd">        Reads the EEG arrays from disk and returns them as a NumPy array</span>
<span class="sd">        together with the corresponding metadata.  Zarr stores are cached</span>
<span class="sd">        after the first open, so repeated calls for trials from the same</span>
<span class="sd">        store are fast.</span>

<span class="sd">        You can supply trials three ways:</span>

<span class="sd">        * Pass a pre-built ``trials`` DataFrame (e.g. from</span>
<span class="sd">          :meth:`lookup_trials`).</span>
<span class="sd">        * Pass filter keyword arguments directly — :meth:`lookup_trials` is</span>
<span class="sd">          called internally.</span>
<span class="sd">        * Pass neither — all trials in the metadata table are loaded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trials : pd.DataFrame, optional</span>
<span class="sd">            Trial metadata table.  Must contain ``path`` and ``array_index``</span>
<span class="sd">            columns.  When omitted, ``**filters`` (if any) are used to build</span>
<span class="sd">            the table automatically via :meth:`lookup_trials`.</span>
<span class="sd">        channels : list, optional</span>
<span class="sd">            Channels to load.  Can be a list of integer indices or channel</span>
<span class="sd">            name strings.  When omitted, all channels are returned.</span>
<span class="sd">        tmin : float, optional</span>
<span class="sd">            Start of the time window in seconds.  Not yet active — the full</span>
<span class="sd">            timecourse is always returned for now.</span>
<span class="sd">        tmax : float, optional</span>
<span class="sd">            End of the time window in seconds.  Not yet active — the full</span>
<span class="sd">            timecourse is always returned for now.</span>
<span class="sd">        average_by : str or list of str, optional</span>
<span class="sd">            Metadata column(s) to average over.  For example</span>
<span class="sd">            ``average_by=&#39;subject&#39;`` returns one averaged waveform per</span>
<span class="sd">            subject instead of one waveform per trial.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Show a progress bar while loading.  Default ``True``.</span>
<span class="sd">        cond : {&#39;and&#39;, &#39;or&#39;}, optional</span>
<span class="sd">            How to combine multiple ``**filters`` (passed to</span>
<span class="sd">            :meth:`lookup_trials`).  Ignored when ``trials`` is provided</span>
<span class="sd">            explicitly.  Default ``&#39;and&#39;``.</span>
<span class="sd">        **filters</span>
<span class="sd">            Column / value pairs forwarded to :meth:`lookup_trials` when</span>
<span class="sd">            ``trials`` is not provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with two keys:</span>

<span class="sd">            ``&#39;data&#39;``</span>
<span class="sd">                NumPy array of shape ``(n_trials, n_channels, n_samples)``</span>
<span class="sd">                (or ``(n_groups, n_channels, n_samples)`` when</span>
<span class="sd">                ``average_by`` is set), dtype ``float32``.</span>
<span class="sd">            ``&#39;metadata&#39;``</span>
<span class="sd">                DataFrame with one row per trial (or per group when</span>
<span class="sd">                ``average_by`` is set), aligned to the first axis of</span>
<span class="sd">                ``&#39;data&#39;``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Inline filtering — no separate lookup_trials call needed</span>
<span class="sd">        &gt;&gt;&gt; result = loader.get_data(subject=&#39;sub-01&#39;, shared=True)</span>
<span class="sd">        &gt;&gt;&gt; eeg = result[&#39;data&#39;]    # shape: (n_trials, n_channels, n_samples)</span>

<span class="sd">        &gt;&gt;&gt; # Pass a pre-built trial table</span>
<span class="sd">        &gt;&gt;&gt; trials = loader.lookup_trials(nsd_id=[1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; result = loader.get_data(trials)</span>

<span class="sd">        &gt;&gt;&gt; # Average across trials, grouped by subject</span>
<span class="sd">        &gt;&gt;&gt; result = loader.get_data(shared=True, average_by=&#39;subject&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_trials</span><span class="p">(</span><span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="k">if</span> <span class="n">filters</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">stores</span> <span class="o">=</span> <span class="n">trials</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">stores</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">store_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="c1">#</span>
        <span class="c1">#channel_names = self.store_cache[stores[0]].attrs[&#39;channel_names&#39;]</span>
        <span class="c1">#sfreq = self.store_cache[stores[0]].attrs[&#39;sfreq&#39;]</span>
        <span class="c1">#timecourse = self.store_cache[stores[0]].attrs[&#39;timecourse&#39;]</span>
        <span class="c1">#nsamples = self.store_cache[stores[0]].shape[-1]</span>
    <span class="c1">#</span>
        <span class="c1">#if channels is not none:</span>
        <span class="c1">#    if isinstance(channels[0], str):</span>
        <span class="c1">#        chan_idcs = np.searchsorted(channels, channel_names)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    chan_idcs = np.arange(len(channel_names))</span>
    <span class="c1">#</span>
        <span class="c1">#tmin = np.argmin(timecourse-tmin) if tmin is not none else 0</span>
        <span class="c1">#tmax = np.argmin(timecourse-tmin) if tmax is not none else nsamples-1</span>
        <span class="c1">#sample_idcs = np.arange(tmin, tmax)#, step)</span>
    <span class="c1">#</span>
        <span class="n">store0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_cache</span><span class="p">[</span><span class="n">stores</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="c1"># Zarr always reads a full contiguous trial block; channel / sample</span>
        <span class="c1"># subsetting is applied in numpy on the in-memory chunk (cheap).</span>
        <span class="n">chan_sel</span> <span class="o">=</span> <span class="n">channels</span> <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">sample_sel</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># placeholder until tmin/tmax conversion is wired up</span>
        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">store0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">store0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1">#</span>
        <span class="c1"># Sort by store then array_index for sequential chunk access;</span>
        <span class="c1"># record original row position so output order matches input trials</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">trials</span><span class="p">[[</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;array_index&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ordered</span><span class="p">[</span><span class="s1">&#39;out_row&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trials</span><span class="p">))</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">ordered</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;array_index&#39;</span><span class="p">])</span>
    <span class="c1">#</span>
        <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">trials</span><span class="p">),</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
    <span class="c1">#</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">prog</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trials</span><span class="p">)),</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Loading Trials&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ordered</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_cache</span><span class="p">[</span><span class="n">path</span><span class="p">]</span>
            <span class="n">arr_idcs</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;array_index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">out_rows</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;out_row&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">data_array</span><span class="p">[</span><span class="n">out_rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">oindex</span><span class="p">[</span><span class="n">arr_idcs</span><span class="p">,</span> <span class="n">chan_sel</span><span class="p">,</span> <span class="n">sample_sel</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">prog</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_rows</span><span class="p">))</span>
    <span class="c1">#</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">trials</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#</span>
        <span class="k">if</span> <span class="n">average_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">average_by</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">average_by</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">average_by</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">data_array</span><span class="p">[</span><span class="n">grp</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">])</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;array_index&#39;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="c1">#</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">data_array</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="n">meta</span><span class="p">}</span></div>


<span class="c1">#</span>
<div class="viewcode-block" id="TrialHandler.iter_data">
<a class="viewcode-back" href="../../../api.html#eeg_access.TrialHandler.iter_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trials</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
        <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tmax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">average_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sort_lookup</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cond</span><span class="o">=</span><span class="s1">&#39;and&#39;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">filters</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over trials in memory-friendly batches.</span>

<span class="sd">        Yields successive chunks of loaded EEG data instead of loading</span>
<span class="sd">        everything at once.  Useful when your full trial set is too large to</span>
<span class="sd">        fit in RAM, or when you want to feed a model batch-by-batch.</span>

<span class="sd">        Each yielded item has the same structure as the dict returned by</span>
<span class="sd">        :meth:`get_data`: a ``&#39;data&#39;`` array and a ``&#39;metadata&#39;`` DataFrame.</span>

<span class="sd">        When ``average_by`` is set, the iterator guarantees that all trials</span>
<span class="sd">        belonging to the same group are included in the same batch before</span>
<span class="sd">        averaging — groups are never split across batches.</span>

<span class="sd">        As with :meth:`get_data`, you can pass a pre-built ``trials`` table,</span>
<span class="sd">        supply ``**filters`` to build one inline, or omit both to iterate</span>
<span class="sd">        over all trials.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trials : pd.DataFrame, optional</span>
<span class="sd">            Trial metadata table.  When omitted, ``**filters`` (if any) are</span>
<span class="sd">            used to build it via :meth:`lookup_trials`, or all trials are</span>
<span class="sd">            used if no filters are given.</span>
<span class="sd">        batch_size : int, optional</span>
<span class="sd">            Maximum number of trials (or group rows) to load per batch.</span>
<span class="sd">            Default is 64.</span>
<span class="sd">        channels : list, optional</span>
<span class="sd">            Channels to load (integer indices or name strings).  All channels</span>
<span class="sd">            are loaded when omitted.</span>
<span class="sd">        tmin : float, optional</span>
<span class="sd">            Start of the time window in seconds (not yet active).</span>
<span class="sd">        tmax : float, optional</span>
<span class="sd">            End of the time window in seconds (not yet active).</span>
<span class="sd">        average_by : str or list of str, optional</span>
<span class="sd">            Metadata column(s) to average over within each batch.</span>
<span class="sd">        sort_lookup : bool, optional</span>
<span class="sd">            Sort trials by store path and array index before iterating for</span>
<span class="sd">            more efficient sequential disk reads.  Default ``True``.</span>
<span class="sd">        cond : {&#39;and&#39;, &#39;or&#39;}, optional</span>
<span class="sd">            How to combine multiple ``**filters``.  Ignored when ``trials``</span>
<span class="sd">            is provided explicitly.  Default ``&#39;and&#39;``.</span>
<span class="sd">        **filters</span>
<span class="sd">            Column / value pairs forwarded to :meth:`lookup_trials` when</span>
<span class="sd">            ``trials`` is not provided.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        dict</span>
<span class="sd">            Same structure as :meth:`get_data`: ``{&#39;data&#39;: np.ndarray,</span>
<span class="sd">            &#39;metadata&#39;: pd.DataFrame}``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Inline filtering</span>
<span class="sd">        &gt;&gt;&gt; for batch in loader.iter_data(subject=&#39;sub-01&#39;, batch_size=32):</span>
<span class="sd">        ...     eeg = batch[&#39;data&#39;]   # shape: (&lt;=32, n_channels, n_samples)</span>
<span class="sd">        ...     meta = batch[&#39;metadata&#39;]</span>
<span class="sd">        ...     process(eeg, meta)</span>

<span class="sd">        &gt;&gt;&gt; # Iterate with per-stimulus averaging</span>
<span class="sd">        &gt;&gt;&gt; trials = loader.lookup_trials(shared=True)</span>
<span class="sd">        &gt;&gt;&gt; for batch in loader.iter_data(trials, batch_size=64, average_by=&#39;subject&#39;):</span>
<span class="sd">        ...     process(batch[&#39;data&#39;], batch[&#39;metadata&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trials</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup_trials</span><span class="p">(</span><span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="k">if</span> <span class="n">filters</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">keys</span> <span class="o">=</span> <span class="p">([</span><span class="n">average_by</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">average_by</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">average_by</span><span class="p">))</span> <span class="k">if</span> <span class="n">average_by</span> <span class="k">else</span> <span class="kc">None</span>
<span class="c1">#</span>
        <span class="k">if</span> <span class="n">sort_lookup</span><span class="p">:</span>
            <span class="n">sort_cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;array_index&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="n">keys</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;array_index&#39;</span><span class="p">]</span>
            <span class="n">trials</span> <span class="o">=</span> <span class="n">trials</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sort_cols</span><span class="p">)</span>
<span class="c1">#</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
            <span class="c1"># accumulate complete groups into batches, never splitting a group</span>
            <span class="n">batch</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">trials</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">batch_size</span> <span class="ow">and</span> <span class="n">batch</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">batch</span><span class="p">),</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span>
                                        <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">average_by</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">batch</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
                <span class="n">batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">batch</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">batch</span><span class="p">),</span> <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span>
                                    <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">average_by</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trials</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span>
                    <span class="n">trials</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">],</span>
                    <span class="n">channels</span><span class="o">=</span><span class="n">channels</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, eeg_access contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>